/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/23 15:30:16 by nbonnet           #+#    #+#             */
/*   Updated: 2025/10/24 18:02:25 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incl/PmergeMe.hpp"


int main (int ac, char **av) {
    if (ac < 2)
    {
        std::cerr << "Error: need at least one argument" << std::endl;
        return 1;
    }
    
    PmergeMe algo;
    algo.init_cont(ac, av);
    algo.display_before(ac, av);
    
    std::deque<int> deque = algo.get_deque();
    merge_sort(deque);

    std::vector<int> vector = algo.get_vector();
    merge_sort(vector);

    
    
    algo.display_after();
    return 0;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   PmergeMe.cpp                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/23 15:30:34 by nbonnet           #+#    #+#             */
/*   Updated: 2025/10/24 18:04:41 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incl/PmergeMe.hpp"

PmergeMe::PmergeMe() {}

PmergeMe::PmergeMe(const PmergeMe& src) : _deque(src._deque), _vector(src._vector) {}

PmergeMe& PmergeMe::operator=(const PmergeMe& rhs) {
    if (this != &rhs)
    {
        _deque = rhs._deque;
        _vector = rhs._vector;

    }
    return *this;
}

PmergeMe::~PmergeMe() {}

void PmergeMe::init_cont(int ac, char **av) {
    int i = 1;
    while (i < ac)
    {
     _deque.push_back(std::atoi(av[i]));
     _vector.push_back(std::atoi(av[i]));
     i++;
    }
}

std::deque<int>& PmergeMe::get_deque() {
    return _deque;
}

std::vector<int>& PmergeMe::get_vector() {
    return _vector;
}


void PmergeMe::display_before(int ac, char **av) {
    std::cout << "Before:";
    int max = 6;
    if (ac > 6)
        max = 5;
    int i = 1;
    while (i != max && i < ac)
    {
        std::cout << " " << av[i];
        i++;
    }
    if (max == 5)
        std::cout << " [...]";
    std::cout << std::endl;
}

void PmergeMe::display_after() {
    std::cout << "After: ";
    int max = 6;
    
    if (_deque.size() > 5)
        max = 5;
    int i = 1;
    while (i != max && i != static_cast<int>(_deque.size()) + 1)
    {
        std::cout << " " << _deque[i - 1];
        i++;
    }
    if (max == 5)
        std::cout << " [...]";
    std::cout << std::endl;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   PmergeMe.hpp                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/23 15:30:04 by nbonnet           #+#    #+#             */
/*   Updated: 2025/10/24 18:09:51 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once
#include <deque>
#include <vector>
#include <string>
#include <iostream>
#include <cstdlib>

class PmergeMe {
    private:
        std::deque<int> _deque;
        std::vector<int> _vector;
        
    public:
        PmergeMe();
        PmergeMe(const PmergeMe &src);
        PmergeMe& operator=(const PmergeMe &rhs);
        ~PmergeMe();

        void init_cont(int ac, char **av);
        void display_before(int ac, char **av);
        void display_after();
        std::deque<int>& get_deque();
        std::vector<int>& get_vector();

};


template <typename Container>
void merge_sort(Container &container) {
    
    if (container.size() <= 1)
        return;
    else if (container.size() == 2) {
        if (container[0] > container[1])
            std::swap(container[0], container[1]);
        return;
    }
    size_t mid = container.size() / 2;
    Container left(container.begin(), container.begin() + mid);
    Container right(container.begin() + mid, container.end());
    
    merge_sort(left);
    merge_sort(right);

    container.clear();
    typename Container::iterator left_it = left.begin();
    typename Container::iterator right_it = right.begin();
    typename Container::iterator left_end = left.end();
    typename Container::iterator right_end = right.end();

    while (left_it != left_end && right_it != right_end) {
        if (*left_it <= *right_it) {
            container.push_back(*left_it);
            ++left_it;
        } else {
            container.push_back(*right_it);
            ++right_it;
        }
    }

    // Ajouter les éléments restants
    while (left_it != left_end) {
        container.push_back(*left_it);
        ++left_it;
    }
    while (right_it != right_end) {
        container.push_back(*right_it);
        ++right_it;
    }
}